@using BlazorBootstrap
@using Ficus

@inject IJSRuntime Js;

<div style="width: 100%;">
  @if (!myFinishedCanvasDrawings)
  {
    <Spinner Type="SpinnerType.Dots" Color="SpinnerColor.Primary"/>
  }

  @if (mySuggestedAdjustment is var (suggestedWidthScale, suggestedHeightScale))
  {
    <div>
      Rendered canvas is too big, suggested scale are (Width: @suggestedWidthScale, Height: @suggestedHeightScale)
    </div>
  }

  <div class="@CanvasContainerClass">
    <canvas id="@myCanvasId.ToString()"></canvas>
  </div>

  <div style="margin-top: 5px;">
    <ColorsLogEventClasses Entries="@myEventClassEntries" Filter="@Filter"/>
  </div>
</div>

@code
{
  private readonly Guid myCanvasId = Guid.NewGuid();

  private bool myFullScreen;
  private bool myFinishedCanvasDrawings;
  private (double X, double Y)? mySuggestedAdjustment;
  private ColorsLogEventClasses.EventClassEntry[] myEventClassEntries = [];


  private string CanvasContainerClass => "colors-log-canvas-container " + (myFinishedCanvasDrawings && mySuggestedAdjustment is null) switch
  {
    true => string.Empty,
    false => "invisible-canvas"
  } + (myFullScreen ? string.Empty : "colors-log-canvas-not-full-screen");


  [Parameter] public required bool IsFullScreen { get; init; }
  [Parameter] public required GrpcColorsEventLog Log { get; init; }
  [Parameter] public double? WidthScale { get; init; }
  [Parameter] public double? HeightScale { get; init; }
  [Parameter] public Action<double, double>? CanvasDimensionsTooLargeHandler { get; init; }
  [Parameter] public string? Filter { get; init; }


  protected override Task OnAfterRenderAsync(bool firstRender)
  {
    if (!firstRender && myFullScreen == IsFullScreen) return Task.CompletedTask;

    myFullScreen = IsFullScreen;
    RedrawCanvas();

    return Task.CompletedTask;
  }

  protected override async Task OnParametersSetAsync()
  {
    myEventClassEntries = await GetEntries();
  }

  private async Task<ColorsLogEventClasses.EventClassEntry[]> GetEntries() =>
    await Js.InvokeAsync<ColorsLogEventClasses.EventClassEntry[]>("createEventClassesEntries", Log);

  public void RedrawCanvas()
  {
    myFinishedCanvasDrawings = false;
    StateHasChanged();

    Task.Delay(100).ContinueWith(async _ =>
    {
      var renderResult = await Js.InvokeAsync<List<double>?>(
        "drawColorsLog", Log, WidthScale ?? 1, HeightScale ?? 1, myCanvasId.ToString(), CanvasColors.Instance, Filter);

      if (renderResult is [var suggestedWidthScale, var suggestedHeightScale])
      {
        mySuggestedAdjustment = (suggestedWidthScale, suggestedHeightScale);
      }
      else
      {
        mySuggestedAdjustment = null;
      }

      myFinishedCanvasDrawings = true;
      StateHasChanged();

      if (renderResult is [var widthScale, var heightScale])
      {
        CanvasDimensionsTooLargeHandler?.Invoke(widthScale, heightScale);
      }
    });
  }
}