@using System.Globalization
@using Ficus
@using FicusDashboard.Layout.Models
@using Radzen
@using Radzen.Blazor
@using Orientation = Radzen.Orientation
@inject IJSRuntime Js


<div style="display: flex; flex-direction: column; width: 100%; height: 100%; padding: 5px;">
  <div style="display: flex; flex-direction: row; flex-grow: 1;">
    <div style="display: flex; flex-direction: column; 
                background: var(--aggregated-data-background); border-radius: 5px; padding: 5px;">
      @if (IsRichUiGraph(Graph))
      {
        @if (myEnhancements is { })
        {
          @foreach (var (index, enhancement) in myEnhancements.Index())
          {
            <div style="display: flex; flex-direction: row; align-items: center;">
              <RadzenCheckBox TValue="bool"
                              @ref="@myCheckBoxes[index]"
                              ValueChanged="@(v => HandleSelectionChange(v, enhancement))"/>

              <div style="margin-left: 5px;">@enhancement</div>
            </div>
          }
        }

        <div style="margin-top: 5px;">Filter:</div>
        <input type="text" @bind="myFilterValue" style="width: 90%"/>
      }

      <div style="margin-top: 5px;">Spacing factor:</div>
      <input type="text" @bind="mySpacingFactor" style="width: 90%"/>

      <RadzenStack Orientation="Orientation.Horizontal"
                   AlignItems="AlignItems.Center"
                   Gap="0.5rem"
                   Style="margin-top: 5px;">
        <RadzenLabel Text="TB"/>
        <RadzenSwitch Name="Orientation" @bind-Value="@myUseLROrientation"/>
        <RadzenLabel Text="LR"/>
      </RadzenStack>

      <RadzenButton Click="ReRenderCanvas" Style="width: 90%; margin-top: 5px;">Rerender</RadzenButton>
      <RadzenButton Click="ExportGraph" Style="width: 90%; margin-top: 5px;">Export to SVG</RadzenButton>
    </div>

    <CanvasComponent @ref="myCanvasComponent" IsFullScreen="@IsFullScreen" RenderingFunc="RenderCanvas"/>
  </div>

  <div style="margin-top: 5px;">
    @if (myAggregatedData is { } data)
    {
      <div style="background: var(--aggregated-data-background); border-radius: 5px; padding: 10px;">
        <div>
          Aggregated Data
        </div>
        <div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 5px; margin-top: 10px;">
          <AggregatedStatInfo Title="Allocated"
                              Value="@data.TotalAllocatedBytes.ToString(CultureInfo.InvariantCulture)"
                              Units="bytes"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.Allocations)"/>

          <AggregatedStatInfo Title="Execution Time"
                              Value="@data.TotalExecutionTime.ToString(CultureInfo.InvariantCulture)" Units="QPC"/>

          <AggregatedStatInfo Title="Buffer Allocated"
                              Value="@data.TotalBufferAllocatedBytes.ToString(CultureInfo.InvariantCulture)"
                              Units="bytes"/>

          <AggregatedStatInfo Title="Buffer Rented"
                              Value="@data.TotalBufferRentedBytes.ToString(CultureInfo.InvariantCulture)"
                              Units="bytes"/>

          <AggregatedStatInfo Title="Buffer Returned"
                              Value="@data.TotalBufferReturnedBytes.ToString(CultureInfo.InvariantCulture)"
                              Units="bytes"/>

          <AggregatedStatInfo Title="Exceptions"
                              Value="@CalculateTotal(data.GlobalSoftwareData.Exceptions)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.Exceptions)"/>

          <AggregatedStatInfo Title="Inlinings Failed"
                              Value="@CalculateTotal(data.GlobalSoftwareData.InliningFailed)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.InliningFailed)"/>

          <AggregatedStatInfo Title="Inlinings Succeeded"
                              Value="@CalculateTotal(data.GlobalSoftwareData.InliningSucceeded)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.InliningSucceeded)"/>

          <AggregatedStatInfo Title="Inlinings Fail Reason"
                              Value="@CalculateTotal(data.GlobalSoftwareData.InliningFailedReasons)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.InliningFailedReasons)"/>

          <AggregatedStatInfo Title="Method Loads"
                              Value="@CalculateTotal(data.GlobalSoftwareData.MethodsLoads)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.MethodsLoads)"/>

          <AggregatedStatInfo Title="Method Unloads"
                              Value="@CalculateTotal(data.GlobalSoftwareData.MethodsUnloads)"
                              Histogram="@PrepareHistogram(data.GlobalSoftwareData.MethodsUnloads)"/>

          @foreach (var counter in data.GlobalSoftwareData.Counters)
          {
            <AggregatedStatInfo Title=@counter.Key Value="@counter.Value.Value.ToString(CultureInfo.InvariantCulture)"
                                Units=@string.Empty/>
          }

          @foreach (var histogram in data.GlobalSoftwareData.Histograms)
          {
            <AggregatedStatInfo Title=@histogram.Key
                                Value="@histogram.Value.Value.Values.Sum().ToString(CultureInfo.InvariantCulture)"
                                Units=@string.Empty
                                Histogram="@PrepareHistogram(histogram.Value.Value)"/>
          }
        </div>
      </div>
    }
  </div>
</div>

@code
{
  private class AggregatedData
  {
    public double TotalAllocatedBytes { get; set; }
    public double TotalExecutionTime { get; set; }
    public double MaxExecutionTime { get; set; }

    public double TotalBufferAllocatedBytes { get; set; }
    public double TotalBufferRentedBytes { get; set; }
    public double TotalBufferReturnedBytes { get; set; }

    public MergedSoftwareData GlobalSoftwareData { get; set; } = new();
  }

  private class MergedSoftwareData
  {
    public Dictionary<string, double> Allocations { get; set; } = new();

    public Dictionary<string, double> InliningFailed { get; set; } = new();
    public Dictionary<string, double> InliningSucceeded { get; set; } = new();
    public Dictionary<string, double> InliningFailedReasons { get; set; } = new();

    public Dictionary<string, double> MethodsLoads { get; set; } = new();
    public Dictionary<string, double> MethodsUnloads { get; set; } = new();

    public CountAndSum BufferAllocatedBytes { get; set; } = new();
    public CountAndSum BufferRentedBytes { get; set; } = new();
    public CountAndSum BufferReturnedBytes { get; set; } = new();

    public Dictionary<string, double> Exceptions { get; set; } = new();

    public HashSet<double> CreatedThreads { get; set; } = [];
    public HashSet<double> TerminatedThreads { get; set; } = [];

    public Dictionary<string, double> HttpRequests { get; set; } = new();

    public Dictionary<string, ValueWithUnits<Dictionary<string, double>>> Histograms { get; set; } = new();
    public Dictionary<string, ValueWithUnits<double>> Counters { get; set; } = new();
  }

  private class CountAndSum
  {
    public double Count { get; set; }
    public double Sum { get; set; }
  }

  private class ValueWithUnits<T>
  {
    public string Units { get; set; }
    public T Value { get; set; }
  }


  private static string[] ourPredefinedEnhancements =
  [
    "Allocations", "Exceptions", "MethodsLoadUnload", "MethodsInlinings", "ArrayPools", "Http", "Sockets", "Threads"
  ];


  [Parameter] public required bool IsFullScreen { get; init; }
  [Parameter] public required GrpcGraph Graph { get; init; }
  [Parameter] public required ProcessCaseData ProcessCaseData { get; init; }
  [Parameter] public GrpcAnnotation? Annotation { get; set; }


  private bool myUseLROrientation = true;
  private string? myFilterValue;
  private string mySpacingFactor = "1.4";

  private CanvasComponent? myCanvasComponent;

  private List<string>? myEnhancements;
  private HashSet<string> mySelectedEnhancements = null!;
  private RadzenCheckBox<bool>[] myCheckBoxes = null!;

  private AggregatedData? myAggregatedData;


  protected override void OnParametersSet()
  {
    myEnhancements = FindAllEnhancements(Graph);
    mySelectedEnhancements = myEnhancements.ToHashSet();
    myCheckBoxes = new RadzenCheckBox<bool>[myEnhancements.Count];
  }

  private static List<string> FindAllEnhancements(GrpcGraph graph)
  {
    var enhancements = new List<string>(ourPredefinedEnhancements);

    var customEnhancements = graph.Edges
      .SelectMany(e => e.AdditionalData)
      .SelectMany(d => ExtractCustomEnhancements(d.SoftwareData))
      .ToHashSet();

    AddNodesCustomEnhancements(graph, customEnhancements);

    enhancements.AddRange(customEnhancements.Order());

    return enhancements;
  }

  private static void AddNodesCustomEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    foreach (var node in graph.Nodes)
    {
      foreach (var enhancement in node.AdditionalData.SelectMany(d => ExtractCustomEnhancements(d.SoftwareData)))
      {
        enhancements.Add(enhancement);
      }

      if (node.InnerGraph is { } innerGraph)
      {
        AddNodesCustomEnhancements(innerGraph, enhancements);
      }
    }
  }

  protected override void OnAfterRender(bool firstRender)
  {
    if (!firstRender) return;

    SetInitialCheckBoxesValues();
    StateHasChanged();
  }

  private void SetInitialCheckBoxesValues()
  {
    if (!IsRichUiGraph(Graph)) return;

    foreach (var checkBox in myCheckBoxes)
    {
      checkBox.Value = true;
    }
  }

  private static IEnumerable<string> ExtractCustomEnhancements(GrpcSoftwareData data) => data switch
  {
    null => [],
    { } => data.HistogramData.Select(h => h.Name).Concat(data.SimpleCounterData.Select(c => c.Name))
  };

  private static bool IsRichUiGraph(GrpcGraph graph) =>
    graph.Edges.Any(e => e.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData())) ||
    graph.Nodes.Any(n => n.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData()) ||
                         n.InnerGraph is { } innerGraph && IsRichUiGraph(innerGraph)
    );

  private async Task<IJSObjectReference> RenderCanvas(string canvasId)
  {
    var enhancements = mySelectedEnhancements.Select(e => e.ToString()).OrderDescending().ToList();
    var spacingFactor = double.TryParse(mySpacingFactor, CultureInfo.InvariantCulture, out var factor) switch
    {
      true => factor,
      false => 1
    };

    myAggregatedData = await Js.InvokeAsync<AggregatedData>("createAggregatedData", Graph, Annotation, myFilterValue);
    StateHasChanged();

    return await Js.InvokeAsync<IJSObjectReference>(
      "drawGraph",
      canvasId,
      Graph,
      Annotation,
      myAggregatedData,
      enhancements,
      myFilterValue,
      spacingFactor,
      IsRichUiGraph(Graph),
      myUseLROrientation
    );
  }

  private string CreateExportFileName() =>
    ProcessCaseData.ProcessData.ProcessName + "_" + ProcessCaseData.Case.DisplayName + "_graph";

  private void HandleSelectionChange(bool selected, string enhancement)
  {
    if (selected)
    {
      mySelectedEnhancements.Add(enhancement);
    }
    else
    {
      mySelectedEnhancements.Remove(enhancement);
    }
  }

  private void ReRenderCanvas() => myCanvasComponent?.ReRenderCanvas();

  private Task ExportGraph() =>
    myCanvasComponent is { } ? myCanvasComponent.ExportGraph(CreateExportFileName()) : Task.CompletedTask;

  private static (string, double)[] PrepareHistogram(Dictionary<string, double> map) =>
    map.OrderBy(p => p.Value).Select(p => (p.Key, p.Value)).ToArray();

  private static string NumberToString(double number) => number.ToString(CultureInfo.InvariantCulture);
  private static string CalculateTotal(Dictionary<string, double> map) => NumberToString(map.Values.Sum());
}