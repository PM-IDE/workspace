@using System.Globalization
@using Ficus
@using FicusDashboard.Layout.Models
@using Radzen
@using Radzen.Blazor
@using Orientation = Radzen.Orientation
@inject IJSRuntime Js


<div style="display: flex; flex-direction: column; width: 100%; height: 100%; padding: 5px;">
  <div style="display: flex; flex-direction: row; flex-grow: 1;">
    <div style="display: flex; flex-direction: column; 
                background: var(--aggregated-data-background); border-radius: 5px; padding: 5px;">
      @if (IsRichUiGraph(Graph))
      {
        @if (myEnhancements is { })
        {
          @foreach (var (index, enhancement) in myEnhancements.Index())
          {
            <div style="display: flex; flex-direction: row; align-items: center;">
              <RadzenCheckBox TValue="bool"
                              @ref="@myCheckBoxes[index]"
                              ValueChanged="@(v => HandleSelectionChange(v, enhancement))"/>

              <div style="margin-left: 5px;">@enhancement</div>
            </div>
          }
        }

        <div style="margin-top: 5px;">Filter:</div>
        <input type="text" @bind="myFilterValue" style="width: 90%"/>
      }

      <div style="margin-top: 5px;">Spacing factor:</div>
      <input type="text" @bind="mySpacingFactor" style="width: 90%"/>

      <RadzenStack Orientation="Orientation.Horizontal"
                   AlignItems="AlignItems.Center"
                   Gap="0.5rem"
                   Style="margin-top: 5px;">
        <RadzenLabel Text="TB"/>
        <RadzenSwitch Name="Orientation" @bind-Value="@myUseLROrientation"/>
        <RadzenLabel Text="LR"/>
      </RadzenStack>

      <RadzenButton Click="ReRenderCanvas" Style="width: 90%; margin-top: 5px;">Rerender</RadzenButton>
      <RadzenButton Click="ExportGraph" Style="width: 90%; margin-top: 5px;">Export to SVG</RadzenButton>
    </div>

    <div style="height: 100%; flex-grow: 1;">
      <CanvasComponent @ref="myCanvasComponent" IsFullScreen="@IsFullScreen" RenderingFunc="RenderCanvas"/>
    </div>
  </div>

  <div style="margin-top: 5px;">
    @if (myAggregatedData is { } data)
    {
      <AggregatedDataRenderer Data="@data"/>
    }
  </div>
</div>

@code
{
  [Parameter] public required bool IsFullScreen { get; init; }
  [Parameter] public required GrpcGraph Graph { get; init; }
  [Parameter] public required ProcessCaseData ProcessCaseData { get; init; }
  [Parameter] public GrpcAnnotation? Annotation { get; set; }


  private bool myUseLROrientation = true;
  private string? myFilterValue;
  private string mySpacingFactor = "1.4";

  private CanvasComponent? myCanvasComponent;

  private List<string>? myEnhancements;
  private HashSet<string> mySelectedEnhancements = null!;
  private RadzenCheckBox<bool>[] myCheckBoxes = null!;

  private AggregatedData? myAggregatedData;


  protected override void OnParametersSet()
  {
    myEnhancements = FindAllEnhancements(Graph);
    mySelectedEnhancements = myEnhancements.ToHashSet();
    myCheckBoxes = new RadzenCheckBox<bool>[myEnhancements.Count];
  }

  private List<string> FindAllEnhancements(GrpcGraph graph)
  {
    var enhancements = new HashSet<string>();

    AddGraphEnhancements(graph, enhancements);

    return enhancements.Order().ToList();
  }

  private void AddGraphEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    AddEdgeEnhancements(graph, enhancements);
    AddNodesEnhancements(graph, enhancements);
  }

  private void AddEdgeEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    foreach (var additionalData in graph.Edges.SelectMany(e => e.AdditionalData))
    {
      AddEnhancements(additionalData.SoftwareData, enhancements);
    }
  }

  private void AddNodesEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    foreach (var node in graph.Nodes)
    {
      foreach (var additionalData in node.AdditionalData)
      {
        AddEnhancements(additionalData.SoftwareData, enhancements);
        if (additionalData.PatternInfo is { Graph: var patternGraph })
        {
          AddGraphEnhancements(patternGraph, enhancements);
        }
      }

      if (node.InnerGraph is { } innerGraph)
      {
        AddGraphEnhancements(innerGraph, enhancements);
      }
    }
  }

  private void AddEnhancements(GrpcSoftwareData data, HashSet<string> enhancements)
  {
    AddPredefinedEnhancements(data, enhancements);
    AddCustomEnhancements(data, enhancements);
  }

  private static class PredefinedEnhancements
  {
    public const string Allocations = "Allocations";
    public const string Exceptions = "Exceptions";
    public const string MethodsLoadUnload = "MethodsLoadUnload";
    public const string MethodsInlinings = "MethodsInlinings";
    public const string ArrayPools = "ArrayPools";
    public const string Http = "Http";
    public const string Sockets = "Sockets";
    public const string Threads = "Threads";
  }

  private static void AddPredefinedEnhancements(GrpcSoftwareData? data, HashSet<string> enhancements)
  {
    if (data is null) return;

    if (data.AllocationsInfo.Count > 0) enhancements.Add(PredefinedEnhancements.Allocations);
    if (data.ExceptionEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Exceptions);
    if (data.MethodsLoadUnloadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsLoadUnload);
    if (data.MethodsInliningEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsInlinings);
    if (data.ArrayPoolEvents.Count > 0) enhancements.Add(PredefinedEnhancements.ArrayPools);
    if (data.HttpEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Http);
    if (data.SocketEvent.Count > 0) enhancements.Add(PredefinedEnhancements.Sockets);
    if (data.ThreadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Threads);
  }

  private void AddCustomEnhancements(GrpcSoftwareData? data, HashSet<string> enhancements)
  {
    if (data is null) return;

    foreach (var name in data.HistogramData.Select(e => e.Name))
    {
      enhancements.Add(name);
    }

    foreach (var name in data.SimpleCounterData.Select(e => e.Name))
    {
      enhancements.Add(name);
    }
  }

  protected override void OnAfterRender(bool firstRender)
  {
    if (!firstRender) return;

    SetInitialCheckBoxesValues();
    StateHasChanged();
  }

  private void SetInitialCheckBoxesValues()
  {
    if (!IsRichUiGraph(Graph)) return;

    foreach (var checkBox in myCheckBoxes)
    {
      checkBox.Value = true;
    }
  }

  private static bool IsRichUiGraph(GrpcGraph graph) =>
    graph.Edges.Any(e => e.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData())) ||
    graph.Nodes.Any(n => n.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData()) ||
                         n.InnerGraph is { } innerGraph && IsRichUiGraph(innerGraph)
    );

  private async Task<IJSObjectReference> RenderCanvas(string canvasId)
  {
    var enhancements = mySelectedEnhancements.Select(e => e.ToString()).OrderDescending().ToList();
    var spacingFactor = double.TryParse(mySpacingFactor, CultureInfo.InvariantCulture, out var factor) switch
    {
      true => factor,
      false => 1
    };

    myAggregatedData = await Js.InvokeAsync<AggregatedData>("createAggregatedData", Graph, Annotation, myFilterValue);
    StateHasChanged();

    return await Js.InvokeAsync<IJSObjectReference>(
      "drawGraph",
      canvasId,
      Graph,
      Annotation,
      myAggregatedData,
      enhancements,
      myFilterValue,
      spacingFactor,
      IsRichUiGraph(Graph),
      myUseLROrientation
    );
  }

  private string CreateExportFileName() =>
    ProcessCaseData.ProcessData.ProcessName + "_" + ProcessCaseData.Case.DisplayName + "_graph";

  private void HandleSelectionChange(bool selected, string enhancement)
  {
    if (selected)
    {
      mySelectedEnhancements.Add(enhancement);
    }
    else
    {
      mySelectedEnhancements.Remove(enhancement);
    }
  }

  private void ReRenderCanvas() => myCanvasComponent?.ReRenderCanvas();

  private Task ExportGraph() =>
    myCanvasComponent is { } ? myCanvasComponent.ExportGraph(CreateExportFileName()) : Task.CompletedTask;
}