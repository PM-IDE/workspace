@using System.Globalization
@using Ficus
@using FicusDashboard.Layout.Models
@using Radzen.Blazor
@inject IJSRuntime Js


<div style="display: flex; flex-direction: column; width: 100%; height: 100%; padding: 5px;">
  <div style="display: flex; flex-direction: row; flex-grow: 1;">
    <EnhancementsSettings @ref="@mySettings" Enhancements="@myEnhancements">
      <RadzenButton Click="ReRenderCanvas" Style="width: 90%; margin-top: 5px;">Rerender</RadzenButton>
      <RadzenButton Click="ExportGraph" Style="width: 90%; margin-top: 5px;">Export to SVG</RadzenButton>
    </EnhancementsSettings>

    <div style="height: 100%; flex-grow: 1;">
      <CanvasComponent @ref="myCanvasComponent" IsFullScreen="@IsFullScreen" RenderingFunc="RenderCanvas"/>
    </div>
  </div>

  <div style="margin-top: 5px;">
    @if (myAggregatedData is { } data)
    {
      <AggregatedDataRenderer Data="@data"/>
    }
  </div>
</div>

@code
{
  [Parameter] public required bool IsFullScreen { get; init; }
  [Parameter] public required GrpcGraph Graph { get; init; }
  [Parameter] public required ProcessCaseData ProcessCaseData { get; init; }
  [Parameter] public GrpcAnnotation? Annotation { get; set; }


  private EnhancementsSettings mySettings = null!;
  private List<string>? myEnhancements;
  private CanvasComponent? myCanvasComponent;
  private AggregatedData? myAggregatedData;


  protected override void OnParametersSet()
  {
    myEnhancements = FindAllEnhancements(Graph);
  }

  private List<string> FindAllEnhancements(GrpcGraph graph)
  {
    var enhancements = new HashSet<string>();

    AddGraphEnhancements(graph, enhancements);

    return enhancements.Order().ToList();
  }

  private void AddGraphEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    AddEdgeEnhancements(graph, enhancements);
    AddNodesEnhancements(graph, enhancements);
  }

  private void AddEdgeEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    foreach (var additionalData in graph.Edges.SelectMany(e => e.AdditionalData))
    {
      AddEnhancements(additionalData.SoftwareData, enhancements);
    }
  }

  private void AddNodesEnhancements(GrpcGraph graph, HashSet<string> enhancements)
  {
    foreach (var node in graph.Nodes)
    {
      foreach (var additionalData in node.AdditionalData)
      {
        AddEnhancements(additionalData.SoftwareData, enhancements);
        if (additionalData.PatternInfo is { Graph: var patternGraph })
        {
          AddGraphEnhancements(patternGraph, enhancements);
        }
      }

      if (node.InnerGraph is { } innerGraph)
      {
        AddGraphEnhancements(innerGraph, enhancements);
      }
    }
  }

  private void AddEnhancements(GrpcSoftwareData data, HashSet<string> enhancements)
  {
    AddPredefinedEnhancements(data, enhancements);
    AddCustomEnhancements(data, enhancements);
  }

  private static class PredefinedEnhancements
  {
    public const string Allocations = "Allocations";
    public const string Exceptions = "Exceptions";
    public const string MethodsLoadUnload = "MethodsLoadUnload";
    public const string MethodsInlinings = "MethodsInlinings";
    public const string ArrayPools = "ArrayPools";
    public const string Http = "Http";
    public const string Sockets = "Sockets";
    public const string Threads = "Threads";
  }

  private static void AddPredefinedEnhancements(GrpcSoftwareData? data, HashSet<string> enhancements)
  {
    if (data is null) return;

    if (data.AllocationsInfo.Count > 0) enhancements.Add(PredefinedEnhancements.Allocations);
    if (data.ExceptionEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Exceptions);
    if (data.MethodsLoadUnloadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsLoadUnload);
    if (data.MethodsInliningEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsInlinings);
    if (data.ArrayPoolEvents.Count > 0) enhancements.Add(PredefinedEnhancements.ArrayPools);
    if (data.HttpEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Http);
    if (data.SocketEvent.Count > 0) enhancements.Add(PredefinedEnhancements.Sockets);
    if (data.ThreadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Threads);
  }

  private void AddCustomEnhancements(GrpcSoftwareData? data, HashSet<string> enhancements)
  {
    if (data is null) return;

    foreach (var name in data.HistogramData.Select(e => e.Name))
    {
      enhancements.Add(name);
    }

    foreach (var name in data.SimpleCounterData.Select(e => e.Name))
    {
      enhancements.Add(name);
    }
  }

  private static bool IsRichUiGraph(GrpcGraph graph) =>
    graph.Edges.Any(e => e.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData())) ||
    graph.Nodes.Any(n => n.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData()) ||
                         n.InnerGraph is { } innerGraph && IsRichUiGraph(innerGraph)
    );

  private async Task<IJSObjectReference> RenderCanvas(string canvasId)
  {
    var enhancements = mySettings.SelectedEnhancements.Select(e => e.ToString()).OrderDescending().ToList();
    var spacingFactor = double.TryParse(mySettings.SpacingFactor, CultureInfo.InvariantCulture, out var factor) switch
    {
      true => factor,
      false => 1
    };

    var changeState = myAggregatedData is null;
    myAggregatedData ??= await Js.InvokeAsync<AggregatedData>("createAggregatedData", Graph, Annotation, mySettings.Filter);

    var reference = await Js.InvokeAsync<IJSObjectReference>(
      "drawGraph",
      canvasId,
      Graph,
      Annotation,
      myAggregatedData,
      enhancements,
      mySettings.Filter,
      spacingFactor,
      IsRichUiGraph(Graph),
      mySettings.UseLROrientation
    );

    if (changeState)
    {
      StateHasChanged();
    }

    return reference;
  }

  private string CreateExportFileName() =>
    ProcessCaseData.ProcessData.ProcessName + "_" + ProcessCaseData.Case.DisplayName + "_graph";

  private void ReRenderCanvas() => myCanvasComponent?.ReRenderCanvas();

  private Task ExportGraph() =>
    myCanvasComponent is { } ? myCanvasComponent.ExportGraph(CreateExportFileName()) : Task.CompletedTask;
}