@using System.Globalization
@using Ficus
@using FicusDashboard.Layout.Models
@using Radzen.Blazor
@inject IJSRuntime Js


<div style="display: flex; flex-direction: column; width: 100%; height: 100%; padding: 5px;">
  <div style="display: flex; flex-direction: row; flex-grow: 1;">
    <GraphLikeEntitySettings @ref="@mySettings" Enhancements="@myEnhancements">
      <RadzenButton Click="ReRenderCanvas" Style="width: 90%; margin-top: 5px;">Rerender</RadzenButton>
      <RadzenButton Click="ExportGraph" Style="width: 90%; margin-top: 5px;">Export to SVG</RadzenButton>
    </GraphLikeEntitySettings>

    <div style="height: 100%; flex-grow: 1;">
      <CanvasComponent @ref="myCanvasComponent" IsFullScreen="@IsFullScreen" RenderingFunc="RenderCanvas"/>
    </div>
  </div>

  <div style="margin-top: 5px;">
    @if (myAggregatedData is { IsEmpty: false } data)
    {
      <AggregatedDataRenderer Data="@data"/>
    }
  </div>
</div>

@code
{
  [Parameter] public required bool IsFullScreen { get; init; }
  [Parameter] public required GrpcGraph Graph { get; init; }
  [Parameter] public required ProcessCaseData ProcessCaseData { get; init; }
  [Parameter] public GrpcAnnotation? Annotation { get; set; }


  private GraphLikeEntitySettings mySettings = null!;
  private List<EnhancementsSettings.EnhancementName>? myEnhancements;
  private CanvasComponent? myCanvasComponent;
  private AggregatedData? myAggregatedData;


  protected override void OnParametersSet()
  {
    myEnhancements = FindAllEnhancements(Graph);
  }

  private List<EnhancementsSettings.EnhancementName> FindAllEnhancements(GrpcGraph graph)
  {
    var enhancements = new HashSet<EnhancementsSettings.EnhancementName>();

    AddGraphEnhancements(graph, enhancements);

    return enhancements.OrderBy(e => e.DisplayName).ToList();
  }

  private void AddGraphEnhancements(GrpcGraph graph, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    AddEdgeEnhancements(graph, enhancements);
    AddNodesEnhancements(graph, enhancements);
  }

  private void AddEdgeEnhancements(GrpcGraph graph, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    foreach (var additionalData in graph.Edges.SelectMany(e => e.AdditionalData))
    {
      AddEnhancements(additionalData.SoftwareData, enhancements);
    }
  }

  private void AddNodesEnhancements(GrpcGraph graph, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    foreach (var node in graph.Nodes)
    {
      foreach (var additionalData in node.AdditionalData)
      {
        AddEnhancements(additionalData.SoftwareData, enhancements);
        if (additionalData.PatternInfo is { Graph: var patternGraph })
        {
          AddGraphEnhancements(patternGraph, enhancements);
        }
      }

      if (node.InnerGraph is { } innerGraph)
      {
        AddGraphEnhancements(innerGraph, enhancements);
      }
    }
  }

  private void AddEnhancements(GrpcSoftwareData data, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    AddPredefinedEnhancements(data, enhancements);
    AddCustomEnhancements(data, enhancements);
  }

  private static class PredefinedEnhancements
  {
    public static EnhancementsSettings.EnhancementName Allocations { get; } = new("Allocations");
    public static EnhancementsSettings.EnhancementName Exceptions { get; } = new("Exceptions");
    public static EnhancementsSettings.EnhancementName MethodsLoadUnload { get; } = new("Methods (Un)Loads");
    public static EnhancementsSettings.EnhancementName MethodsInlinings { get; } = new("Methods Inlinings");
    public static EnhancementsSettings.EnhancementName ArrayPools { get; } = new("Array Pools");
    public static EnhancementsSettings.EnhancementName Http { get; } = new("Http");
    public static EnhancementsSettings.EnhancementName Sockets { get; } = new("Sockets");
    public static EnhancementsSettings.EnhancementName Threads { get; } = new("Threads");
  }

  private static void AddPredefinedEnhancements(GrpcSoftwareData? data, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    if (data is null) return;

    if (data.AllocationsInfo.Count > 0) enhancements.Add(PredefinedEnhancements.Allocations);
    if (data.ExceptionEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Exceptions);
    if (data.MethodsLoadUnloadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsLoadUnload);
    if (data.MethodsInliningEvents.Count > 0) enhancements.Add(PredefinedEnhancements.MethodsInlinings);
    if (data.ArrayPoolEvents.Count > 0) enhancements.Add(PredefinedEnhancements.ArrayPools);
    if (data.HttpEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Http);
    if (data.SocketEvent.Count > 0) enhancements.Add(PredefinedEnhancements.Sockets);
    if (data.ThreadEvents.Count > 0) enhancements.Add(PredefinedEnhancements.Threads);
  }

  private void AddCustomEnhancements(GrpcSoftwareData? data, HashSet<EnhancementsSettings.EnhancementName> enhancements)
  {
    if (data is null) return;

    AddCustomEnhancementsNames(data.HistogramData.Select(h => h.Base), enhancements);
    AddCustomEnhancementsNames(data.SimpleCounterData.Select(c => c.Base), enhancements);
    AddCustomEnhancementsNames(data.ActivitiesDurationsData.Select(d => d.Base), enhancements);
  }

  private static void AddCustomEnhancementsNames(
    IEnumerable<GrpcGenericEnhancementBase> bases,
    HashSet<EnhancementsSettings.EnhancementName> enhancements
  )
  {
    foreach (var (name, displayName, group) in bases.Select(b => (b.Name, CreateCustomEnhancementName(b), b.Group)))
    {
      enhancements.Add(new EnhancementsSettings.EnhancementName(name, displayName, string.IsNullOrWhiteSpace(group) ? null : group));
    }
  }

  private static string CreateCustomEnhancementName(GrpcGenericEnhancementBase @base) => @base.Name;

  private static bool IsRichUiGraph(GrpcGraph graph) =>
    graph.Edges.Any(e => e.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData())) ||
    graph.Nodes.Any(n => n.AdditionalData.Any(d => d.DataCase.IsRichUiAdditionalData()) ||
                         n.InnerGraph is { } innerGraph && IsRichUiGraph(innerGraph)
    );

  private async Task<IJSObjectReference> RenderCanvas(string canvasId)
  {
    var enhancements = mySettings.SelectedEnhancements;
    var spacingFactor = double.TryParse(mySettings.SpacingFactor, CultureInfo.InvariantCulture, out var factor) switch
    {
      true => factor,
      false => 1
    };

    var changeState = myAggregatedData is null;
    myAggregatedData ??= await Js.InvokeAsync<AggregatedData>("createAggregatedData", Graph, Annotation, mySettings.Filter);

    var reference = await Js.InvokeAsync<IJSObjectReference>(
      "drawGraph",
      canvasId,
      Graph,
      Annotation,
      myAggregatedData,
      enhancements,
      mySettings.Filter,
      spacingFactor,
      IsRichUiGraph(Graph),
      mySettings.UseLROrientation,
      mySettings.UseEventClassesAsLabels
    );

    if (changeState)
    {
      StateHasChanged();
    }

    return reference;
  }

  private string CreateExportFileName() =>
    ProcessCaseData.ProcessData.ProcessName + "_" + ProcessCaseData.Case.DisplayName + "_graph";

  private void ReRenderCanvas() => myCanvasComponent?.ReRenderCanvas();

  private Task ExportGraph() =>
    myCanvasComponent is { } ? myCanvasComponent.ExportGraph(CreateExportFileName()) : Task.CompletedTask;
}