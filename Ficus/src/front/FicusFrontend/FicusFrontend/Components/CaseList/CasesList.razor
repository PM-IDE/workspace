@using FicusFrontend.Components.SidebarList
@using FicusFrontend.Services.Cases
@using FicusFrontend.Utils
@using JetBrains.Collections.Viewable
@using JetBrains.Lifetimes
@inherits ComponentBase;

@inject IProcessesService ProcessService;

<SidebarList TItem="ProcessData"
             TInnerItem="Case"
             TId="string" 
             ItemType="Process"
             Title="Processes"
             Items="myProcesses.Values.OrderBy(p => p.Id).ToList()"
             InnerItemSelected="HandleCaseSelection"/>

@code
{
  private readonly Dictionary<string, CollectionItemInfo<ProcessData, Case, string>> myProcesses = [];
  private readonly LifetimeDefinitionsByKey<string> myProcessesLifetimes = new();
  private readonly LifetimeDefinitionsByKey<string> myCasesLifetimes = new();
  private readonly SequentialLifetimes mySequentialLifetimes = new(Lifetime.Eternal);

  private Pipeline mySelectedPipeline = null!;
  private Lifetime myCurrentPipelineLifetime;
  private Case? mySelectedCase;


  [Parameter] public Action<ProcessData, Case>? CaseSelected { get; set; }
  [Parameter] public Pipeline? SelectedPipeline { get; set; }


  private void HandleCaseSelection(ProcessData process, Case @case)
  {
    mySelectedCase = @case;
    CaseSelected?.Invoke(process, @case);
  }

  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    if (SelectedPipeline is null) return;
    if (ReferenceEquals(mySelectedPipeline, SelectedPipeline)) return;

    mySelectedPipeline = SelectedPipeline;
    myCurrentPipelineLifetime = mySequentialLifetimes.Next();
    mySelectedPipeline.Processes.AdviseAddRemove(myCurrentPipelineLifetime, HandleProcessAddRemove);

    StateHasChanged();
  }

  private void HandleProcessAddRemove(AddRemove addRemove, string key, ProcessData? process)
  {
    switch (addRemove)
    {
      case AddRemove.Add:
      {
        if (process is null) return;

        var processCollectionItemInfo = CreateItemInfoFromProcess(process);
        myProcesses[key] = processCollectionItemInfo;

        var processLifetime = myProcessesLifetimes.CreateNested(key, myCurrentPipelineLifetime);
        process.ProcessCases.AdviseAddRemove(processLifetime, HandleCaseAddRemove);

        break;
      }
      case AddRemove.Remove:
      {
        myProcessesLifetimes.TerminateAndRemove(key);
        myProcesses.Remove(key);

        break;
      }
      default:
        throw new ArgumentOutOfRangeException(nameof(addRemove), addRemove, null);
    }
  }

  private void HandleCaseAddRemove(AddRemove caseAddRemove, string caseKey, Case? caseModel)
  {
    if (caseModel is null) return;

    switch (caseAddRemove)
    {
      case AddRemove.Add: 
      {
        myProcesses[caseModel.ParentProcess.ProcessName].InnerItems[caseKey] = CreateInnerCollectionItemFrom(caseModel);
        
        var processLifetime = myProcessesLifetimes.Get(caseModel.ParentProcess.ProcessName);
        var caseLifetime = myCasesLifetimes.CreateNested(caseKey, processLifetime);
        caseModel.ContextValues.Change.Advise(caseLifetime, _ => HandleCaseContextValuesChange(caseKey, caseModel));

        break;
      }
      case AddRemove.Remove:
      {
        myProcesses[caseModel.ParentProcess.ProcessName].InnerItems.Remove(caseKey);
        myCasesLifetimes.TerminateAndRemove(caseKey);

        break;
      }
      default:
        throw new ArgumentOutOfRangeException(nameof(caseAddRemove), caseAddRemove, null);
    }

    StateHasChanged();
  }

  private void HandleCaseContextValuesChange(string caseKey, Case caseModel)
  {
    if (ReferenceEquals(caseModel, mySelectedCase)) return;

    var collectionItemInfo = myProcesses[caseModel.Name];
    collectionItemInfo.InnerItems[caseKey].InnerItem.UserData.PutData(ComponentsKeys.ProcessingStateKey, ItemProcessingState.Updated);

    StateHasChanged();
  }

  private CollectionItemInfo<ProcessData, Case, string> CreateItemInfoFromProcess(ProcessData process)
  {
    return new CollectionItemInfo<ProcessData, Case, string>
    {
      Id = process.ProcessName,
      Name = process.ProcessName,
      Item = process,
      InnerItems = process.ProcessCases.Values.Select(CreateInnerCollectionItemFrom).ToDictionary(c => c.Id, c => c)
    };
  }

  private InnerCollectionItemInfo<Case, string> CreateInnerCollectionItemFrom(Case @case)
  {
    var innerItem = new InnerCollectionItemInfo<Case, string>
    {
      Id = @case.Name,
      InnerItem = @case,
      ListItemInfo = new ListItemInfo
      {
        Name = @case.Name,
        UpdatedAt = @case.CreatedAt,
      }
    };

    innerItem.InnerItem.UserData.GetOrCreate(ComponentsKeys.ProcessingStateKey, static () => ItemProcessingState.New);

    return innerItem;
  }
}