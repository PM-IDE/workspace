@using FicusFrontend.Components.SidebarList
@using FicusFrontend.Services.Cases
@using JetBrains.Collections.Viewable
@using JetBrains.Lifetimes
@inherits ComponentBase;

@inject IProcessesService ProcessService;

<SidebarList TCollectionItem="ProcessData"
             TCollectionInnerItem="Case"
             TId="string"
             ItemType="Process"
             Title="Processes"
             Items="myProcesses.Values.OrderBy(p => p.Id).ToList()"
             InnerItemSelected="HandleCaseSelection"/>

@code
{
  private readonly Dictionary<string, CollectionItemInfo<ProcessData, Case, string>> myProcesses = [];
  private readonly Dictionary<string, LifetimeDefinition> myProcessesLifetimes = [];
  private readonly Dictionary<string, LifetimeDefinition> myCasesLifetimes = [];
  private readonly SequentialLifetimes mySequentialLifetimes = new(Lifetime.Eternal);

  private Pipeline mySelectedPipeline = null!;
  private Lifetime myCurrentPipelineLifetime;
  private Case? mySelectedCase;


  [Parameter] public Action<ProcessData, Case>? CaseSelected { get; set; }
  [Parameter] public Pipeline? SelectedPipeline { get; set; }


  private void HandleCaseSelection(ProcessData process, Case @case)
  {
    mySelectedCase = @case;
    CaseSelected?.Invoke(process, @case);
  }

  protected override void OnParametersSet()
  {
    base.OnParametersSet();

    if (SelectedPipeline is null) return;
    if (ReferenceEquals(mySelectedPipeline, SelectedPipeline)) return;

    mySelectedPipeline = SelectedPipeline;
    myCurrentPipelineLifetime = mySequentialLifetimes.Next();
    mySelectedPipeline.Processes.AdviseAddRemove(myCurrentPipelineLifetime, HandleProcessAddRemove);

    StateHasChanged();
  }

  private void HandleProcessAddRemove(AddRemove addRemove, string key, ProcessData? process)
  {
    switch (addRemove)
    {
      case AddRemove.Add:
      {
        if (process is null) return;

        var processLifetimeDef = myCurrentPipelineLifetime.CreateNested();
        myProcessesLifetimes[key] = processLifetimeDef;

        var collectionItemInfo = CreateItemInfoFromProcess(process);
        myProcesses[key] = collectionItemInfo;

        process.ProcessCases.AdviseAddRemove(processLifetimeDef.Lifetime, HandleCaseAddRemove);

        break;
      }
      case AddRemove.Remove:
      {
        if (myProcessesLifetimes.Remove(key, out var processLifetimeDef))
        {
          processLifetimeDef.Terminate();
        }

        myProcesses.Remove(key);
        break;
      }
      default:
        throw new ArgumentOutOfRangeException(nameof(addRemove), addRemove, null);
    }
  }

  private void HandleCaseAddRemove(AddRemove caseAddRemove, string caseKey, Case? caseModel)
  {
    if (caseModel is null) return;

    switch (caseAddRemove)
    {
      case AddRemove.Add:
      {
        var processLifetimeDef = myProcessesLifetimes[caseModel.ParentProcess.ProcessName].Lifetime;

        var caseLifetimeDef = processLifetimeDef.CreateNested();
        myCasesLifetimes[caseKey] = caseLifetimeDef;

        myProcesses[caseModel.ParentProcess.ProcessName].InnerItems[caseKey] = CreateInnerCollectionItemFrom(caseModel);

        caseModel.ContextValues.Change.Advise(
          caseLifetimeDef.Lifetime, _ => HandleCaseContextValuesChange(caseKey, caseModel));

        break;
      }
      case AddRemove.Remove:
      {
        myProcesses[caseModel.ParentProcess.ProcessName].InnerItems.Remove(caseKey);

        if (myCasesLifetimes.Remove(caseKey, out var caseLifetimeDef))
        {
          caseLifetimeDef.Terminate();
        }

        break;
      }
    }

    StateHasChanged();
  }

  private void HandleCaseContextValuesChange(string caseKey, Case caseModel)
  {
    if (ReferenceEquals(caseModel, mySelectedCase)) return;

    var collectionItemInfo = myProcesses[caseModel.Name];
    collectionItemInfo.InnerItems[caseKey].ListItemInfo.ProcessingState = ItemProcessingState.Updated;

    StateHasChanged();
  }

  private CollectionItemInfo<ProcessData, Case, string> CreateItemInfoFromProcess(ProcessData process)
  {
    return new CollectionItemInfo<ProcessData, Case, string>
    {
      Id = process.ProcessName,
      Name = process.ProcessName,
      Item = process,
      InnerItems = process.ProcessCases.Values.Select(CreateInnerCollectionItemFrom).ToDictionary(c => c.Id, c => c)
    };
  }

  private InnerCollectionItemInfo<Case, string> CreateInnerCollectionItemFrom(Case @case)
  {
    return new InnerCollectionItemInfo<Case, string>
    {
      Id = @case.Name,
      InnerItem = @case,
      ListItemInfo = new ListItemInfo
      {
        Name = @case.Name,
        UpdatedAt = @case.CreatedAt,
        ProcessingState = ItemProcessingState.New
      }
    };
  }
}