@using FicusFrontend.Services.Cases
@using JetBrains.Lifetimes
@using FicusFrontend.Components.SidebarList
@using JetBrains.Collections.Viewable
@inject IProcessesService ProcessService;


<SidebarList TCollectionItem="Subscription"
             TCollectionInnerItem="Pipeline"
             TId="Guid"
             ItemType="Subscription"
             Title="Subscriptions"
             Items="mySubscriptions.Values.OrderBy(p => p.Name).ToList()"
             InnerItemSelected="HandlePipelineSelection"/>

@code
{
    private class SubscriptionState
    {
        public bool IsExpanded { get; set; } = true;
    }

    private readonly Dictionary<Guid, CollectionItemInfo<Subscription, Pipeline, Guid>> mySubscriptions = [];
    private readonly Dictionary<Guid, LifetimeDefinition> mySubscriptionLifetimes = [];

    private Pipeline? mySelectedPipeline;


    [Parameter] public Action<Pipeline>? PipelineSelected { get; set; }


    protected override void OnInitialized()
    {
        base.OnInitialized();

        ProcessService.Subscriptions.AdviseAddRemove(Lifetime.Eternal, HandleSubscriptionAddRemove);
        ProcessService.AnyPipelineSubEntityUpdated.Advise(Lifetime.Eternal, HandleAnyPipelineSubEntityUpdated);
    }

    private void HandleSubscriptionAddRemove(AddRemove addRemove, Guid id, Subscription? subscription)
    {
        if (subscription is null) return;

        switch (addRemove)
        {
            case AddRemove.Add:
            {
                var itemInfo = CreateCollectionItemInfoFrom(subscription);
                mySubscriptions[id] = itemInfo;

                var subscriptionLifetimeDef = new LifetimeDefinition();
                mySubscriptionLifetimes[id] = subscriptionLifetimeDef;

                subscription.Pipelines.AdviseAddRemove(subscriptionLifetimeDef.Lifetime, HandlePipelineAddRemove);

                break;
            }
            case AddRemove.Remove:
            {
                mySubscriptions.Remove(id);
                mySubscriptionLifetimes[id].Terminate();
                break;
            }
            default:
                throw new ArgumentOutOfRangeException(nameof(addRemove), addRemove, null);
        }

        StateHasChanged();
    }

    private void HandlePipelineAddRemove(AddRemove addRemove, Guid id, Pipeline? pipeline)
    {
        if (pipeline is null) return;

        var itemInfo = mySubscriptions[pipeline.ParentSubscription.Id];

        switch (addRemove)
        {
            case AddRemove.Add:
                itemInfo.InnerItems[id] = CreateInnerCollectionItemFrom(pipeline);
                break;
            case AddRemove.Remove:
                itemInfo.InnerItems.Remove(id);
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(addRemove), addRemove, null);
        }

        StateHasChanged();
    }

    private void HandleAnyPipelineSubEntityUpdated(Pipeline pipeline)
    {
        if (ReferenceEquals(pipeline, mySelectedPipeline)) return;

        var pipelineItemInfo = mySubscriptions[pipeline.ParentSubscription.Id].InnerItems[pipeline.Id];
        pipelineItemInfo.ListItemInfo.ProcessingState = ItemProcessingState.Updated;

        StateHasChanged();
    }

    private CollectionItemInfo<Subscription, Pipeline, Guid> CreateCollectionItemInfoFrom(Subscription subscription) => new()
    {
        Id = subscription.Id,
        Name = subscription.Name,
        Item = subscription,
        InnerItems = subscription.Pipelines.Values
            .Select(CreateInnerCollectionItemFrom)
            .ToDictionary(info => info.Id, info => info)
    };

    private InnerCollectionItemInfo<Pipeline, Guid> CreateInnerCollectionItemFrom(Pipeline pipeline) => new()
    {
        Id = pipeline.Id,
        InnerItem = pipeline,
        ListItemInfo = new ListItemInfo
        {
            Name = pipeline.Name,
            UpdatedAt = DateTime.Now,
            ProcessingState = ItemProcessingState.New
        }
    };

    private void HandlePipelineSelection(Subscription subscription, Pipeline pipeline)
    {
        mySelectedPipeline = pipeline;
        PipelineSelected?.Invoke(pipeline);
    }
}