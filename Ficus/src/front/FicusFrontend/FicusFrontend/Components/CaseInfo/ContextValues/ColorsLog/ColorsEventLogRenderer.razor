@using System.Drawing
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using BlazorBootstrap
@using Ficus
@using JetBrains.Threading
@using Radzen.Blazor
@inject ILogger<ColorsEventLogRenderer> Logger


<DoubleInput @ref="myWidthScaleInput"
             Title="Width Scale"
             InitialValue="1"
             Max="100"
             Min="0" />

<DoubleInput @ref="myHeightScaleInput"
             Title="Height Scale"
             InitialValue="1"
             Max="100"
             Min="0" />

<div class="rerender-button-container">
  <RadzenButton Text="Rerender" Click="RedrawCanvas"></RadzenButton>
</div>

@if (!myFinishedCanvasDrawings)
{
  <Spinner Type="SpinnerType.Dots" Color="SpinnerColor.Primary"/>
}

<div class="@CanvasContainerClass">
  <BECanvas Width="@((long)myCanvasWidth)" Height="@((long)myCanvasHeight)" @ref="myCanvas"></BECanvas>
</div>

@code
{
  private BECanvasComponent myCanvas;
  private DoubleInput? myWidthScaleInput;
  private DoubleInput? myHeightScaleInput;

  private bool myFinishedCanvasDrawings;

  private const double AxisDelta = 5;
  private const double AxisWidth = 2;

  private const int DefaultRectWidth = 5;
  private const int DefaultRectHeight = 5;
  private const double AxisTextHeight = 14;

  private double myCanvasWidth = 300;
  private double myCanvasHeight = 400;


  private double RectWidth => DefaultRectWidth * (myWidthScaleInput?.CurrentValue ?? 1);
  private double RectHeight => DefaultRectHeight * (myHeightScaleInput?.CurrentValue ?? 1);

  private string CanvasContainerClass => "colors-log-canvas-container " + myFinishedCanvasDrawings switch
  {
    true => string.Empty,
    false => "invisible-canvas"
  };


  [Parameter] public required GrpcColorsEventLog Log { get; init; }


  protected override void OnParametersSet()
  {
    RecalculateCanvasDimensions();
  }

  private void RecalculateCanvasDimensions()
  {
    myCanvasHeight = (int)(Log.Traces.Count * RectHeight + 2 * AxisDelta + AxisWidth + 2 * AxisTextHeight);
    myCanvasWidth = Log.Traces.Select(t => t.EventColors.Aggregate(0.0, (prev, rect) => prev + rect.Length * RectWidth)).Max();
  }

  protected override Task OnAfterRenderAsync(bool firstRender)
  {
    if (!firstRender) return Task.CompletedTask;

    StartRedrawingCanvas().NoAwait();

    return Task.CompletedTask;
  }

  private Task StartRedrawingCanvas()
  {
    RecalculateCanvasDimensions();
    return Task.Run(async () =>
    {
      try
      {
        await Task.Delay(500);
        var context = await myCanvas.CreateCanvas2DAsync();
        await context.ClearRectAsync(0, 0, myCanvasWidth, myCanvasHeight);

        var y = AxisTextHeight;

        foreach (var trace in Log.Traces)
        {
          await context.BeginBatchAsync();

          var x = AxisDelta + AxisWidth + AxisDelta;
          foreach (var rect in trace.EventColors)
          {
            var color = Log.Mapping[(int)rect.ColorIndex].Color;
            var rgb = Color.FromArgb((int)color.Red, (int)color.Green, (int)color.Blue).ToHexString();

            await context.SetFillStyleAsync(rgb);

            var length = RectWidth * rect.Length;
            await context.FillRectAsync(x, y, length, RectHeight);
            x += length;
          }

          y += RectHeight;

          await context.EndBatchAsync();
        }

        await DrawAxis(context);

        myFinishedCanvasDrawings = true;
        StateHasChanged();
      }
      catch (Exception ex)
      {
        Logger.LogError(ex, "Failed to render canvas");
      }
    });
  }

  private async Task DrawAxis(Canvas2DContext context)
  {
    await context.SetFillStyleAsync(CanvasColors.Axis.ToHexaString());
    await context.FillRectAsync(AxisDelta, AxisTextHeight, AxisWidth, myCanvasHeight - AxisDelta - 2 * AxisTextHeight);

    var horizontalAxisY = myCanvasHeight - AxisDelta - AxisWidth - AxisTextHeight;
    await context.FillRectAsync(AxisDelta, horizontalAxisY, myCanvasWidth, AxisWidth);

    await context.SetFontAsync("10px serif");

    var tracesCountText = Log.Traces.Count.ToString();
    await context.SetTextAlignAsync(TextAlign.Center);
    await context.StrokeTextAsync(tracesCountText, AxisDelta, AxisTextHeight);

    var maxEventsInTraceCountText = Log.Traces.Select(t => t.EventColors.Count).Max().ToString();
    var textMeasures = await context.MeasureTextAsync(maxEventsInTraceCountText);
    await context.StrokeTextAsync(maxEventsInTraceCountText, myCanvasWidth - textMeasures.Width / 2, horizontalAxisY + AxisWidth + AxisTextHeight);
  }

  private void RedrawCanvas(MouseEventArgs obj)
  {
    myFinishedCanvasDrawings = false;
    StateHasChanged();
    StartRedrawingCanvas().NoAwait();
  }

}