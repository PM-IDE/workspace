@using System.Drawing
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using BlazorBootstrap
@using Ficus
@using JetBrains.Threading
@using Radzen.Blazor

@inject IJSRuntime Js
@inject ILogger<ColorsEventLogRenderer> Logger

<div>
  Height Scale: @myHeightScale
</div>
<div>
  <RadzenSlider Value="@myHeightScale" 
                TValue="double" 
                Max="100" 
                Min="1" 
                Step="1" 
                Change="value => UpdateScale(ref myHeightScale, value)"></RadzenSlider>
</div>

<div>
  Width Scale: @myWidthScale
</div>
<div>
  <RadzenSlider Value="@myWidthScale" 
                TValue="double" 
                Max="1" 
                Min="0" 
                Step="0.01" 
                Change="value => UpdateScale(ref myWidthScale, value)"></RadzenSlider>
</div>

<div class="rerender-button-container">
  <RadzenButton Text="Rerender" Click="RedrawCanvas"></RadzenButton>
</div>

@if (!myFinishedCanvasDrawings)
{
  <Spinner Type="SpinnerType.Dots" Color="SpinnerColor.Primary"/>
}

<div class="@CanvasContainerClass">
  <BECanvas Width="@myCanvasWidth" Height="@myCanvasHeight" @ref="myCanvas"></BECanvas>
</div>

@code {
  private BECanvasComponent myCanvas;
  private bool myFinishedCanvasDrawings = false;

  private int myDefaultRectWidth = 5;
  private int myDefaultRectHeight = 5;
  private int myCanvasWidth = 300;
  private int myCanvasHeight = 400;
  private double myWidthScale = 1;
  private double myHeightScale = 1;


  private double RectWidth => myDefaultRectWidth * myWidthScale;
  private double RectHeight => myDefaultRectHeight * myHeightScale;

  private string CanvasContainerClass => "colors-log-canvas-container " + myFinishedCanvasDrawings switch
  {
    true => string.Empty,
    false => "invisible-canvas"
  };


  [Parameter] public required GrpcColorsEventLog Log { get; init; }


  protected override void OnParametersSet()
  {
    RecalculateCanvasDimensions();
  }

  private void RecalculateCanvasDimensions()
  {
    myCanvasHeight = (int)(Log.Traces.Count * RectHeight);
    myCanvasWidth = (int)(Log.Traces.Select(t => t.EventColors.Count).Max() * RectWidth);
  }

  protected override Task OnAfterRenderAsync(bool firstRender)
  {
    if (!firstRender) return Task.CompletedTask;

    StartRedrawingCanvas().NoAwait();
    
    return Task.CompletedTask;
  }

  private Task StartRedrawingCanvas()
  {
    RecalculateCanvasDimensions();
    return Task.Run(async () =>
    {
      try
      {
        await Task.Delay(500);
        var context = await myCanvas.CreateCanvas2DAsync();

        await context.ClearRectAsync(0, 0, myCanvasWidth, myCanvasHeight);

        var y = 0d;

        foreach (var trace in Log.Traces)
        {
          await context.BeginBatchAsync();

          var x = 0d;
          foreach (var rect in trace.EventColors)
          {
            var color = Log.Mapping[(int)rect.ColorIndex].Color;
            var rgb = Color.FromArgb((int)color.Red, (int)color.Green, (int)color.Blue).ToHexString();

            await context.SetFillStyleAsync(rgb);
            await context.FillRectAsync(x, y, RectWidth, RectHeight);
            x += RectWidth;
          }

          y += RectHeight;

          await context.EndBatchAsync();
        }

        myFinishedCanvasDrawings = true;
        StateHasChanged();
      }
      catch (Exception ex)
      {
        Logger.LogError(ex, "Failed to render canvas");
      }
    });
  }

  private void UpdateScale(ref double field, double value)
  {
    field = value;
    StateHasChanged();
  }

  private void RedrawCanvas(MouseEventArgs obj)
  {
    myFinishedCanvasDrawings = false;
    StateHasChanged();
    StartRedrawingCanvas().NoAwait();
  }
}