@using Ficus
@using FicusFrontend.Components.CaseInfo.ContextValues.ColorsLog
<h3>LogTimelineRenderer</h3>

<ColorsEventLogRenderer Log="FromTimeline()"/>

@code {
  [Parameter] public required GrpcLogTimelineDiagram TimelineDiagram { get; init; }

  private GrpcColorsEventLog FromTimeline()
  {
    var colorsGenerator = new ColorsGenerator();

    const string BackgroundKey = nameof(BackgroundKey);
    const string SeparatorKey = nameof(SeparatorKey);
    var colors = new Dictionary<string, uint>()
    {
      [BackgroundKey] = 0,
      [SeparatorKey] = 1
    };

    var mappings = new List<GrpcColorsEventLogMapping>()
    {
      new()
      {
        Name = nameof(BackgroundKey),
        Color = new GrpcColor()
        {
          Red = 0,
          Green = 0,
          Blue = 0
        }
      },
      new()
      {
        Name = nameof(SeparatorKey),
        Color = new GrpcColor()
        {
          Red = 0,
          Green = 0,
          Blue = 0
        }
      }
    };

    const ulong RectWidth = 1;
    var maxStamp = 0ul;
    var maxEvents = 0ul;
    foreach (var traceDiagram in TimelineDiagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        maxStamp = Math.Max(maxStamp, thread.Events.Last().Stamp);
        maxEvents = Math.Max(maxEvents, (ulong)thread.Events.Count);
      }
    }

    var colorsLog = new List<GrpcColorsTrace>();
    foreach (var traceDiagram in TimelineDiagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        var colorsTrace = new List<GrpcColoredRectangle>();
        var lastX = 0ul;
        foreach (var @event in thread.Events)
        {
          if (!colors.ContainsKey(@event.Name))
          {
            var color = colorsGenerator.Next();
            colors[@event.Name] = (uint)colors.Count;
            mappings.Add(new GrpcColorsEventLogMapping
            {
              Color = color,
              Name = @event.Name
            });
          }

          var rectX = @event.Stamp;
          if (lastX != rectX)
          {
            colorsTrace.Add(new GrpcColoredRectangle
            {
              ColorIndex = (uint)colors[@event.Name],
              StartIndex = (uint)lastX,
              Length = (uint)(rectX - lastX),
            });
          }

          colorsTrace.Add(new GrpcColoredRectangle
          {
            ColorIndex = (uint)colors[@event.Name],
            StartIndex = (uint)rectX,
            Length = (uint)RectWidth,
          });

          lastX = rectX + RectWidth;
        }

        colorsLog.Add(new GrpcColorsTrace
        {
          ConstantWidth = false,
          EventColors =
          {
            colorsTrace
          }
        });
      }

      colorsLog.Add(new GrpcColorsTrace
      {
        EventColors =
        {
          new GrpcColoredRectangle
          {
            Length = (uint)(maxEvents + maxStamp),
            StartIndex = 0,
            ColorIndex = colors[BackgroundKey]
          }
        }
      });
    }

    return new GrpcColorsEventLog
    {
      Mapping =
      {
        mappings
      },
      Traces =
      {
        colorsLog
      }
    };
  }

  class ColorsGenerator
  {
    private readonly HashSet<(int, int, int)> myUsed = [(0, 0, 0), (255, 255, 255)];

    public GrpcColor Next()
    {
      var color = GenerateRandomColor();
      while (myUsed.Contains(color))
      {
        color = GenerateRandomColor();
      }

      myUsed.Add(color);
      return new GrpcColor
      {
        Red = (uint)color.Item1,
        Green = (uint)color.Item2,
        Blue = (uint)color.Item3,
      };
    }

    private static (int, int, int) GenerateRandomColor()
    {
      return (Random.Shared.Next(0, 256), Random.Shared.Next(0, 256), Random.Shared.Next(0, 256));
    }
  }

}