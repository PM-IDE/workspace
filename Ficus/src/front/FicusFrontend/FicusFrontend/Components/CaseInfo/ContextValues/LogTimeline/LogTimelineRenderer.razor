@using System.Drawing
@using Ficus
@using FicusFrontend.Components.CaseInfo.ContextValues.ColorsLog
@using JetBrains.Threading
@using Radzen.Blazor

@inject IJSRuntime Js;

<div style="margin: 10px;">
  <DoubleInput @ref="myScaleInput"
               Title="Length and Start Position Scale"
               InitialValue="myScaleInputInitialValue"
               Max="100"
               Min="0"/>

  <DoubleInput @ref="myWidthScaleInput"
               Title="Width Scale"
               InitialValue="myWidthScaleInputInitialValue"
               Max="100"
               Min="0"/>

  <DoubleInput @ref="myHeightScaleInput"
               Title="Height Scale"
               InitialValue="myHeightScaleInitialValue"
               Max="100"
               Min="0"/>

  <div class="rerender-button-container">
    <RadzenButton Text="Rerender" Click="RedrawCanvas"></RadzenButton>
  </div>

  <div style="margin-top: 10px">
    <ColorsEventLogRenderer @ref="myRenderer" 
                            Log="FromTimeline()" 
                            WidthScale="myWidthScaleInput?.CurrentValue"
                            HeightScale="myHeightScaleInput?.CurrentValue" />
  </div>
</div>

@code {
  private const string BackgroundKey = nameof(BackgroundKey);
  private const string SeparatorKey = nameof(SeparatorKey);
  private const uint RectWidth = 1;

  private double myScaleInputInitialValue = 1;
  private double myWidthScaleInputInitialValue = 1;
  private double myHeightScaleInitialValue = 1;
  
  private ColorsEventLogRenderer? myRenderer;
  private DoubleInput? myScaleInput;
  private DoubleInput? myWidthScaleInput;
  private DoubleInput? myHeightScaleInput;


  [Parameter] public required GrpcLogTimelineDiagram TimelineDiagram { get; init; }


  private void RedrawCanvas()
  {
    myScaleInputInitialValue = myScaleInput?.CurrentValue ?? 1;
    myWidthScaleInputInitialValue = myWidthScaleInput?.CurrentValue ?? 1;
    myHeightScaleInitialValue = myHeightScaleInput?.CurrentValue ?? 1;

    StateHasChanged();
    myRenderer?.RedrawCanvas();
  }

  private GrpcColorsEventLog FromTimeline()
  {
    var colorsGenerator = new ColorsGenerator();
    var (colors, mappings) = InitState();
    var maxWidth = CalculateMaxWidth(TimelineDiagram);
    var scale = myScaleInput?.CurrentValue ?? 1;

    var colorsLog = new List<GrpcColorsTrace>();
    foreach (var traceDiagram in TimelineDiagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        var colorsTrace = new List<GrpcColoredRectangle>();
        var lastX = 0.0;
        foreach (var @event in thread.Events)
        {
          if (!colors.ContainsKey(@event.Name))
          {
            var color = colorsGenerator.Next();
            colors[@event.Name] = (uint)colors.Count;
            mappings.Add(NewMapping(@event.Name, color));
          }

          var rectX = @event.Stamp * scale;
          if (lastX < rectX)
          {
            colorsTrace.Add(NewRect(colors[BackgroundKey], lastX, rectX - lastX));
          }

          colorsTrace.Add(NewRect(colors[@event.Name], rectX, RectWidth));
          lastX = rectX + RectWidth;
        }

        colorsLog.Add(NewTrace(colorsTrace));
      }

      colorsLog.Add(NewTrace([NewRect(colors[SeparatorKey], 0, maxWidth * scale)]));
    }

    return new GrpcColorsEventLog
    {
      Mapping =
      {
        mappings
      },
      Traces =
      {
        colorsLog
      }
    };
  }

  private static (Dictionary<string, uint>, List<GrpcColorsEventLogMapping>) InitState()
  {
    var colors = new Dictionary<string, uint>
    {
      [BackgroundKey] = 0,
      [SeparatorKey] = 1
    };

    var mappings = new List<GrpcColorsEventLogMapping>
    {
      new()
      {
        Name = nameof(BackgroundKey),
        Color = NewColor(CanvasColors.Instance.Background)
      },
      new()
      {
        Name = nameof(SeparatorKey),
        Color = NewColor(CanvasColors.Instance.Axis)
      }
    };

    return (colors, mappings);
  }

  private static GrpcColorsTrace NewTrace(List<GrpcColoredRectangle> colorsTrace) => new()
  {
    ConstantWidth = false,
    EventColors =
    {
      colorsTrace
    }
  };

  private static uint CalculateMaxWidth(GrpcLogTimelineDiagram diagram)
  {
    var maxStamp = 0ul;
    var maxEvents = 0ul;
    foreach (var traceDiagram in diagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        maxStamp = Math.Max(maxStamp, thread.Events.Last().Stamp);
        maxEvents = Math.Max(maxEvents, (ulong)thread.Events.Count);
      }
    }

    return (uint)(maxStamp + maxEvents);
  }

  private static GrpcColoredRectangle NewRect(uint colorIndex, double startX, double length) => new()
  {
    ColorIndex = colorIndex,
    StartX = startX,
    Length = length
  };

  private static GrpcColorsEventLogMapping NewMapping(string name, GrpcColor color) => new()
  {
    Color = color,
    Name = name
  };

  private static GrpcColor NewColor(Color color) => new()
  {
    Red = color.R,
    Green = color.G,
    Blue = color.B
  };

  class ColorsGenerator
  {
    private readonly HashSet<(int, int, int)> myUsed = [(0, 0, 0), (255, 255, 255)];

    public GrpcColor Next()
    {
      var color = GenerateRandomColor();
      while (myUsed.Contains(color))
      {
        color = GenerateRandomColor();
      }

      myUsed.Add(color);
      return new GrpcColor
      {
        Red = (uint)color.Item1,
        Green = (uint)color.Item2,
        Blue = (uint)color.Item3,
      };
    }

    private static (int, int, int) GenerateRandomColor()
    {
      return (Random.Shared.Next(0, 256), Random.Shared.Next(0, 256), Random.Shared.Next(0, 256));
    }
  }
}