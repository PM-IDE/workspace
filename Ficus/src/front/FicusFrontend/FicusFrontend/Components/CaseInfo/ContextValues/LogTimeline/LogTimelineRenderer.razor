@using Ficus
@using FicusFrontend.Components.CaseInfo.ContextValues.ColorsLog
<h3>LogTimelineRenderer</h3>

<ColorsEventLogRenderer Log="FromTimeline()"/>

@code {
  private const string BackgroundKey = nameof(BackgroundKey);
  private const string SeparatorKey = nameof(SeparatorKey);
  private const uint RectWidth = 1;


  [Parameter] public required GrpcLogTimelineDiagram TimelineDiagram { get; init; }


  private GrpcColorsEventLog FromTimeline()
  {
    var colorsGenerator = new ColorsGenerator();
    var (colors, mappings) = InitState();
    var maxWidth = CalculateMaxWidth(TimelineDiagram);

    var colorsLog = new List<GrpcColorsTrace>();
    foreach (var traceDiagram in TimelineDiagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        var colorsTrace = new List<GrpcColoredRectangle>();
        var lastX = 0ul;
        foreach (var @event in thread.Events)
        {
          if (!colors.ContainsKey(@event.Name))
          {
            var color = colorsGenerator.Next();
            colors[@event.Name] = (uint)colors.Count;
            mappings.Add(NewMapping(@event.Name, color));
          }

          var rectX = @event.Stamp;
          if (lastX != rectX)
          {
            colorsTrace.Add(NewRect(colors[@event.Name], (uint)lastX, (uint)(rectX - lastX)));
          }

          colorsTrace.Add(NewRect(colors[@event.Name], (uint)rectX, RectWidth));

          lastX = rectX + RectWidth;
        }

        colorsLog.Add(NewTrace(colorsTrace));
      }

      colorsLog.Add(NewTrace([NewRect(colors[BackgroundKey], 0, maxWidth)]));
    }

    return new GrpcColorsEventLog
    {
      Mapping =
      {
        mappings
      },
      Traces =
      {
        colorsLog
      }
    };
  }

  private static (Dictionary<string, uint>, List<GrpcColorsEventLogMapping>) InitState()
  {
    var colors = new Dictionary<string, uint>
    {
      [BackgroundKey] = 0,
      [SeparatorKey] = 1
    };

    var mappings = new List<GrpcColorsEventLogMapping>
    {
      new()
      {
        Name = nameof(BackgroundKey),
        Color = NewColor(0, 0, 0),
      },
      new()
      {
        Name = nameof(SeparatorKey),
        Color = NewColor(255, 255, 255)
      }
    };

    return (colors, mappings);
  }

  private static GrpcColorsTrace NewTrace(List<GrpcColoredRectangle> colorsTrace) => new()
  {
    ConstantWidth = false,
    EventColors =
    {
      colorsTrace
    }
  };

  private static uint CalculateMaxWidth(GrpcLogTimelineDiagram diagram)
  {
    var maxStamp = 0ul;
    var maxEvents = 0ul;
    foreach (var traceDiagram in diagram.Traces)
    {
      foreach (var thread in traceDiagram.Threads)
      {
        maxStamp = Math.Max(maxStamp, thread.Events.Last().Stamp);
        maxEvents = Math.Max(maxEvents, (ulong)thread.Events.Count);
      }
    }

    return (uint)(maxStamp + maxEvents);
  }

  private static GrpcColoredRectangle NewRect(uint colorIndex, uint startIndex, uint length) => new()
  {
    ColorIndex = colorIndex,
    StartIndex = startIndex,
    Length = length,
  };

  private static GrpcColorsEventLogMapping NewMapping(string name, GrpcColor color) => new()
  {
    Color = color,
    Name = name
  };

  private static GrpcColor NewColor(uint red, uint green, uint blue) => new()
  {
    Red = red,
    Green = green,
    Blue = blue
  };

  class ColorsGenerator
  {
    private readonly HashSet<(int, int, int)> myUsed = [(0, 0, 0), (255, 255, 255)];

    public GrpcColor Next()
    {
      var color = GenerateRandomColor();
      while (myUsed.Contains(color))
      {
        color = GenerateRandomColor();
      }

      myUsed.Add(color);
      return new GrpcColor
      {
        Red = (uint)color.Item1,
        Green = (uint)color.Item2,
        Blue = (uint)color.Item3,
      };
    }

    private static (int, int, int) GenerateRandomColor()
    {
      return (Random.Shared.Next(0, 256), Random.Shared.Next(0, 256), Random.Shared.Next(0, 256));
    }
  }

}